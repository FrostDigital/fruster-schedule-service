const testUtils = require("fruster-test-utils");
const JobRepo = require("../lib/repos/JobRepo");
const fixtures = require("./support/fixtures");
const specConstants = require("./support/spec-constants");
const conf = require("../conf");
const constants = require("../constants");
const { getCronRunner } = require("../schedule-service");
const jobStates = require("../constants").jobStates;
const { wait } = require("./support/spec-utils");

describe("CronRunner", () => {
	let jobRepo;

	testUtils.startBeforeEach(
		specConstants.testUtilsOptions(async ({ db }) => {
			try {
				await db
					.collection(constants.collections.invocations)
					.deleteMany({});
				await db.collection(constants.collections.jobs).deleteMany({});
			} catch (err) {
				console.error(err);
			}
			jobRepo = new JobRepo(db);
		})
	);

	afterEach(() => {
		getCronRunner().stop();
	});

	describe("with jobs to synchronize", () => {
		beforeEach(async () => {
			await addMockJobs([fixtures.fireOnceJob(), fixtures.cronJob()]);
			await getCronRunner().synchronize();
		});

		it("should synchronize jobs", async () => {
			const job1 = fixtures.fireOnceJob();
			const job2 = fixtures.cronJob();

			const cronRunner = getCronRunner();

			expect(cronRunner.jobs.length).toBe(2);

			let scheduledJob1 = cronRunner.getJob(job1.id);
			let scheduledJob2 = cronRunner.getJob(job2.id);

			expect(scheduledJob1.state).toBe(jobStates.scheduled);
			expect(scheduledJob1.subject).toBe(job1.subject);
			expect(scheduledJob1.cron).toBeUndefined();
			expect(scheduledJob1.at).toBeDefined();
			expect(scheduledJob1.timeZone).toEqual(conf.defaultTimeZone);

			expect(scheduledJob2.state).toBe(jobStates.scheduled);
			expect(scheduledJob2.subject).toBe(job2.subject);
			expect(scheduledJob2.cron).toEqual(job2.cron);
			expect(scheduledJob2.at).toBeUndefined();
			expect(scheduledJob2.timeZone).toEqual(conf.defaultTimeZone);
		});

		it("should synchronize jobs and purge ones in memory that is deleted", async () => {
			const cronRunner = getCronRunner();

			// Add fake job that does not exist in database
			cronRunner.jobs.push({
				id: "fakeJob",
				stop: function () {},
			});

			await cronRunner.synchronize();
			await wait(100);

			expect(cronRunner.jobs.length).toBe(2);
			expect(cronRunner.getJob("fakeJob")).toBeUndefined();
		});
	});

	describe("with jobs to run", () => {
		let fireOnceJob;
		let repeatedJob;

		beforeEach(() => {
			const nowish = new Date(Date.now() + 100);
			fireOnceJob = fixtures.fireOnceJob({ at: nowish });
			repeatedJob = fixtures.cronJob({ cron: "* * * * * *" });
		});

		describe("once (at)", () => {
			beforeEach(async () => {
				await addMockJobs([fireOnceJob]);
				await getCronRunner().synchronize();
			});

			it("should run job once", async () => {
				const mockFireOnce = testUtils.mockService({
					subject: "foo-service.fire-once",
					response: { status: 200 },
				});

				await wait(500);

				expect(mockFireOnce.requests.length).toBe(1);

				const job = await jobRepo.get(fireOnceJob.id);

				expect(job.state).toBe(jobStates.completed);
				expect(job.updated).toBeDefined();
				expect(job.lastFailure).toBeUndefined();

				const invocations = await jobRepo.invocationRepo.findAll();

				expect(invocations.length).toBe(1);
				expect(invocations[0].success).toBe(true);
				expect(invocations[0].response.status).toBe(200);
				expect(invocations[0].jobId).toBe(job.id);
			});

			it("should run job once and save failure", async () => {
				testUtils.mockService({
					subject: "foo-service.fire-once",
					response: {
						status: 400,
						error: {
							id: "generated by bus",
						},
					},
				});

				await wait(500);

				const job = await jobRepo.get(fireOnceJob.id);

				expect(job.state).toBe(jobStates.failed);

				const invocations = await jobRepo.invocationRepo.findAll();

				expect(invocations.length).toBe(1);
				expect(invocations[0].success).toBe(false);
				expect(invocations[0].response.status).toBe(400);
			});
		});

		describe("repeated jobs (cron)", () => {
			beforeEach(async () => {
				await addMockJobs([repeatedJob]);
				await getCronRunner().synchronize();
			});

			it("should run repeated job", async () => {
				const mockFireOnce = testUtils.mockService({
					subject: "foo-service.cron",
					response: { status: 200 },
				});

				await wait(1000);

				expect(mockFireOnce.requests.length).toBe(1);

				const job = await jobRepo.get(repeatedJob.id);

				expect(job.state).toBe(jobStates.scheduled);
			});

			it("should run repeated job and save failure", async () => {
				testUtils.mockService({
					subject: "foo-service.cron",
					response: {
						status: 400,
						error: {
							id: "generated by bus",
						},
					},
				});

				await wait(1000);

				const job = await jobRepo.get(repeatedJob.id);

				expect(job.state).toBe(jobStates.scheduledAfterFailure);
				expect(job.lastFailure).toBeDefined();
				expect(job.failureCount).toBe(1);
			});

			it("should fail if failureCount exceeds maxFailures", async () => {
				getCronRunner().jobs[0].maxFailures = 1;

				testUtils.mockService({
					subject: "foo-service.cron",
					response: {
						status: 400,
						error: {
							id: "generated by bus",
						},
					},
				});

				await wait(1000);

				const job = await jobRepo.get(repeatedJob.id);

				expect(job.state).toBe(jobStates.failed);
				expect(job.lastFailure).toBeDefined();
				expect(job.failureCount).toBe(1);
			});

			it("should reset failureCount after success", async () => {
				testUtils.mockService({
					subject: "foo-service.cron",
					responses: [
						{
							status: 400,
							error: {
								id: "generated by bus",
							},
						},
						{
							status: 200,
							data: {},
						},
					],
				});

				await wait(1000);

				let job = await jobRepo.get(repeatedJob.id);

				expect(job.state).toBe(jobStates.scheduledAfterFailure);
				expect(job.lastFailure).toBeDefined();
				expect(job.failureCount).toBe(1);
				expect(job.totalFailureCount).toBe(1);

				await wait(1000);

				job = await jobRepo.get(repeatedJob.id);

				expect(job.state).toBe(jobStates.scheduled);
				expect(job.failureCount).toBe(0);
				expect(job.totalFailureCount).toBe(1);
			});
		});
	});

	async function addMockJobs(jobs) {
		await Promise.all(jobs.map((job) => jobRepo.create(job)));
	}
});
