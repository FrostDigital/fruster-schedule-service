const mongo = require("mongodb");
const testUtils = require("fruster-test-utils");
const bus = require("fruster-bus");
const CronRunner = require("../lib/cron/CronRunner");
const JobRepo = require("../lib/repos/JobRepo");
const fixtures = require("./support/fixtures");
const conf = require("../conf");
const lolex = require("lolex");
const jobStates = require("../constants").jobStates;
const mockService = testUtils.mockService;

describe("CronRunner", () => {

	let cronRunner;
	let jobRepo;

	testUtils.startBeforeEach({
		mongoUrl: "mongodb://localhost:27017/cron-runner-test",		
		bus: bus,
		afterStart: (connection) => {		
			jobRepo = new JobRepo(connection.db);
			cronRunner = new CronRunner(jobRepo);
			return Promise.resolve();
		}
	});

	afterEach(() => {
		cronRunner.stop();
	});

	describe("with jobs to synchronize", () => {

		beforeEach(done => {
			addMockJobs().then(done);
		});
		
		it("should synchronize jobs", (done) => {
			const job1 = fixtures.fireOnceJob();
			const job2 = fixtures.cronJob();

			cronRunner.synchronize().then(() => {
				expect(cronRunner.jobs.length).toBe(2);
				
				let scheduledJob1 = cronRunner.getJob(job1.id);
				let scheduledJob2 = cronRunner.getJob(job2.id);
				
				expect(scheduledJob1.state).toBe(jobStates.scheduled);
				expect(scheduledJob1.subject).toBe(job1.subject);
				expect(scheduledJob1.cron).toBeUndefined();
				expect(scheduledJob1.at).toEqual(new Date(job1.at));
				expect(scheduledJob1.timeZone).toEqual(conf.defaultTimeZone);

				expect(scheduledJob2.state).toBe(jobStates.scheduled);
				expect(scheduledJob2.subject).toBe(job2.subject);
				expect(scheduledJob2.cron).toEqual(job2.cron);
				expect(scheduledJob2.at).toBeUndefined();
				expect(scheduledJob2.timeZone).toEqual(conf.defaultTimeZone);

				done();
			});		
		});

		it("should synchronize jobs and purge ones in memory that is deleted", (done) => {
			const job1 = fixtures.fireOnceJob();
			const job2 = fixtures.cronJob();

			// Add fake job that does not exist in database
			cronRunner.jobs.push({
				id: "fakeJob",
				stop: function() {}
			});

			cronRunner.synchronize().then(() => {
				expect(cronRunner.jobs.length).toBe(2);			
				expect(cronRunner.getJob("fakeJob")).toBeUndefined();				
				done();
			});		
		});

	});

	describe("with jobs to run", () => {
		
		let clock;
		let fireOnceJob;
		let repeatedJob;

		beforeEach(() => {		
			const nowish = new Date(Date.now() + 1000);	
			fireOnceJob = fixtures.fireOnceJob({at: nowish});
			repeatedJob = fixtures.cronJob({cron: "* * * * * *"});
		});


		describe("once (at)", () => {
			
			beforeEach((done) => {		
				addMockJobs(fireOnceJob)
					.then(() => cronRunner.synchronize())				
					.then(done);
			});

			it("should run job once", async (done) => {			
				let numInvocations = 0;
				mockService({
					subject: "foo-service.fire-once",
					expectData: (data) => {
						numInvocations++;
						expect(data).toBe("fireOnceJobData");
					}
				});

				await wait();

				expect(numInvocations).toBe(1);

				const job = await jobRepo.get(fireOnceJob.id);
				
				expect(job.state).toBe(jobStates.completed);
				expect(job.updated).toBeDefined();
				expect(job.lastFailure).toBeUndefined();

				const invocations = await jobRepo.invocationRepo.findAll();
				
				expect(invocations.length).toBe(1);
				expect(invocations[0].success).toBe(true);
				expect(invocations[0].response.status).toBe(200);
				expect(invocations[0].jobId).toBe(job.id);				
				
				done();			
			});

			it("should run job once and save failure", async (done) => {
				mockService({
					subject: "foo-service.fire-once",			
					response: {
						status: 400,
						error: {
							id: "generated by bus"
						}
					}
				});

				await wait();

				const job = await jobRepo.get(fireOnceJob.id);
		
				expect(job.state).toBe(jobStates.failed);
				
				const invocations = await jobRepo.invocationRepo.findAll();
				
				expect(invocations.length).toBe(1);
				expect(invocations[0].success).toBe(false);
				expect(invocations[0].response.status).toBe(400);

				done();					
			});
		});

		describe("repeated jobs (cron)", () => {
			
			beforeEach((done) => {		
				addMockJobs(repeatedJob)
					.then(() => cronRunner.synchronize())				
					.then(done);
			});

			it("should run repeated job", (done) => {
				let numInvocations = 0;
				mockService({
					subject: "foo-service.cron",
					expectData: (data) => {
						numInvocations++;
						expect(data).toBe("cronJobData");
					}
				});

				wait(1200)
					.then(() => {
						expect(numInvocations).toBe(1);
					})
					.then(() => wait(1200))
					.then(() => {
						expect(numInvocations).toBeGreaterThan(1);
					})
					.then(() => jobRepo.get(repeatedJob.id))
					.then(job => {
						expect(job.state).toBe(jobStates.scheduled);
						done();
					});
			});

			it("should run repeated job and save failure", (done) => {
				mockService({
					subject: "foo-service.cron",
					response: {
						status: 400,
						error: {
							id: "generated by bus"
						}
					}
				});

				wait(1200)					
					.then(() => jobRepo.get(repeatedJob.id))
					.then(job => {
						expect(job.state).toBe(jobStates.scheduledAfterFailure);
						expect(job.lastFailure).toBeDefined();
						expect(job.failureCount).toBe(1);
						done();
					});
			});

			it("should fail if failureCount exceeds maxFailures", (done) => {				
				cronRunner.jobs[0].maxFailures = 1;
				
				mockService({
					subject: "foo-service.cron",
					response: {
						status: 400,
						error: {
							id: "generated by bus"
						}
					}
				});

				wait(1200)					
					.then(() => jobRepo.get(repeatedJob.id))
					.then(job => {
						expect(job.state).toBe(jobStates.failed);
						expect(job.lastFailure).toBeDefined();
						expect(job.failureCount).toBe(1);
						done();
					});
			});

			it("should reset failureCount after success", (done) => {								
				let count = 1;
				mockService({
					subject: "foo-service.cron",
					response: () => {
						if(count == 1) {
							count++;
							// fail first invocation
							return {
								status: 400,
								error: {
									id: "generated by bus"
								}
							}							
						} else {
							// next is successful
							return {
								status: 200,
								data: {}					
							}
						}
					} 
				});

				wait(1200)					
					.then(() => jobRepo.get(repeatedJob.id))
					.then(job => {
						expect(job.state).toBe(jobStates.scheduledAfterFailure);
						expect(job.lastFailure).toBeDefined();
						expect(job.failureCount).toBe(1);
						expect(job.totalFailureCount).toBe(1);	
					})
					.then(() => wait(1200))
					.then(() => jobRepo.get(repeatedJob.id))
					.then(job => {
						expect(job.state).toBe(jobStates.scheduled);						
						expect(job.failureCount).toBe(0);
						expect(job.totalFailureCount).toBe(1);
						done();
					});					
			});
		});		
	});


	function wait(timeout = 1000) {
		return new Promise(resolve => {
			setTimeout(() => {
				resolve();				
			}, timeout)
		})
	}

	function addMockJobs(job) {	
		const fireOnceJob = fixtures.fireOnceJob();
		const cronJob = fixtures.cronJob();

		if(job) {
			return jobRepo.create(job);
		} else {
			return Promise.all([
				jobRepo.create(fireOnceJob),
				jobRepo.create(cronJob)
			]);			
		}
	}

	
});